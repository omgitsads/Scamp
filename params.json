{"name":"Scamp","body":"# Scamp\r\n\r\nA framework for writing [Campfire](http://campfirenow.com/) bots. Scamp is in early development so use it at your own risk, pull requests welcome.\r\n\r\nScamp is designed to be simple, to get out of your way and to let you do what you want. It doesn't have any baggage, so no administration web interfaces, no built in commands. It's a blank slate for you to build on.\r\n\r\nIf you like or use Scamp I'd love to hear from you. Drop me at line at will at 37signals dot com and tell me how you are using it.\r\n\r\n## Requirements\r\n\r\nRuby >= 1.9.2 (At least for the named captures)\r\n\r\n## Installation\r\n\r\n`gem install scamp` or put `gem 'scamp'` in your Gemfile.\r\n\r\n## Usage and Examples\r\n\r\n### The most simple example:\r\n\r\n``` ruby\r\nrequire 'scamp'\r\nrequire 'scamp-campfire-adapter'\r\n\r\nScamp.new do |scamp|\r\n  scamp.adapter :campfire, Scamp::Campfire::Adapter, :api_key => \"YOUR API KEY\", \r\n                                                     :subdomain => \"yoursubdomain\",\r\n                                                     :rooms => [293788,\"Monitoring\"]\r\n\r\n  # Simple matching based on regex or string:\r\n  scamp.match \"ping\" do |msg|\r\n    say \"pong\"\r\n  end\r\nend\r\n```\r\n\r\n### Everyone wants an image search\r\n\r\n``` ruby\r\nrequire 'scamp'\r\nrequire 'cgi'\r\n\r\nScamp.new do |scamp|\r\n  scamp.adapter :campfire, Scamp::Campfire::Adapter, :api_key => \"YOUR API KEY\", \r\n                                                     :subdomain => \"yoursubdomain\",\r\n                                                     :rooms => [293788,\"Monitoring\"]\r\n\r\n  scamp.match /^artme (?<search>\\w+)/ do |msg|\r\n    url = \"http://ajax.googleapis.com/ajax/services/search/images?rsz=large&start=0&v=1.0&q=#{CGI.escape(search)}\"\r\n    http = EventMachine::HttpRequest.new(url).get\r\n    http.errback { say \"Couldn't get #{url}: #{http.response_status.inspect}\" }\r\n    http.callback {\r\n      if http.response_header.status == 200\r\n        results = Yajl::Parser.parse(http.response)\r\n        if results['responseData']['results'].size > 0\r\n          say results['responseData']['results'][0]['url']\r\n        else\r\n          say \"No images matched #{search}\"\r\n        end\r\n      else\r\n        # logger.warn \"Couldn't get #{url}\"\r\n        say \"Couldn't get #{url}\"\r\n      end\r\n    }\r\n  end\r\nend\r\n```\r\n\r\n### A more in-depth run through\r\n\r\nMatchers are tested in order and all that satisfy the match and conditions will be run. Careful, Scamp listens to itself, you could easily create an infinite loop. Look in the examples dir for more.\r\n\r\n``` ruby\r\nrequire 'scamp'\r\n\r\n# Add :verbose => true to get debug output, otherwise the logger will output INFO\r\nScamp.new do |scamp|\r\n  scamp.adapter :campfire, Scamp::Campfire::Adapter, :api_key => \"YOUR API KEY\", \r\n                                                     :subdomain => \"yoursubdomain\", \r\n                                                     :rooms => [293788,\"Monitoring\"],\r\n                                                     :verbose => true\r\n\r\n  # \r\n  # Simple matching based on regex or string:\r\n  # \r\n  scamp.match /^repeat (\\w+), (\\w+)$/ do |msg|\r\n    say \"You said #{matches[0]} and #{matches[1]}\"\r\n  end\r\n\r\n  # \r\n  # Named captures become available in your match block\r\n  # \r\n  scamp.match /^say (?<yousaid>.+)$/ do |msg|\r\n    say \"You said #{yousaid}\"\r\n  end\r\n\r\n  # \r\n  # A list of commands is available as command_list this matcher uses it\r\n  # to format a help text\r\n  # \r\n  scamp.match \"help\" do |msg|\r\n    max_command_length = command_list.map{|cl| cl.first.to_s }.max_by(&:size).size\r\n    format_string = \"%#{max_command_length + 1}s\"\r\n    formatted_commands = command_list.map{|action, conds| \"#{sprintf(format_string, action)} | #{conds.size == 0 ? '' : conds.inspect}\"}\r\n    say <<-EOS\r\n#{sprintf(\"%-#{max_command_length + 1}s\", \"Command match\")} | Conditions\r\n--------------------------------------------------------------------------------\r\n#{formatted_commands.join(\"\\n\")}\r\n    EOS\r\n  end\r\nend\r\n  \r\n```\r\n\r\nScamp will also run _all_ match blocks that an input string matches, you can make Scamp only run the first block it matches by passing in :first\\_match\\_only => true:\r\n\r\n``` ruby\r\nScamp.new :first_match_only => true do |scamp|\r\nend\r\n```\r\n\r\n## TODO\r\n\r\n\t* Allow multiple values for conditions, eg: :conditions => {:user => [\"Some User\", \"Some Other User\"]}\r\n\r\n## How to contribute\r\n\r\nHere's the most direct way to get your work merged into the project:\r\n\r\n1. Fork the project\r\n2. Clone down your fork\r\n3. Create a feature branch\r\n4. Add your feature + tests\r\n5. Document new features in the README\r\n6. Make sure everything still passes by running the tests\r\n7. If necessary, rebase your commits into logical chunks, without errors\r\n8. Push the branch up\r\n9. Send a pull request for your branch\r\n\r\nTake a look at the TODO list or known issues for some inspiration if you need it.\r\n\r\n## Thanks\r\n\r\nFirst class support, commits and pull requests, thanks guys!\r\n\r\n* [Caius Durling](http://caius.name/)\r\n* Sudara Williams of [Ramen Music](http://ramenmusic.com)\r\n* [Dom Hodgson](http://www.thehodge.co.uk/) (for the name)\r\n* [Adam Holt](http://adamholt.co.uk/)\r\n\r\n## License\r\n\r\nSee LICENSE.md","tagline":"A platform agnostic bot framework.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}